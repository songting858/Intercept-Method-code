                                                                                        // E-I integration with multiple Es and Is getting involved insimultaneously
// voltage clamp is used to extract excitatory and inhibitory conductance

// read input information from the file "input_time.dat" generated by the matlab 
// file "setup_multipleinputs.m". The synaptic time starts from 400ms to allow the
// voltage clamp reach the steady state first

// normally the reversal potential needs to be changed once in order to apply the 
// intercept method and the results are recorded in the output files "multi_EI_Vclamp_1.dat"
// and "multi_EI_Vclamp_2.dat", respectively. 

/*apical trunk list: 0(41.50)-2(94.47)-14(122.82)-28(151.46)-30(179.70)-32(195.53)-40(201.79)-
	-44(227.96)-52(254.45)-60(262.17)-66(268.27)-72(283.71)-74(311.14)-78(343.59)*/

load_file("preload_files.hoc")

cvode.active(0)
dt=0.1
tstop=1400

ni = 5*100    		//number of Is 
ne = 20*100    		//number of Es

//====================declare variables=========================================
objref Estim[ne], Istim[ni]
double I_loc[ni], E_loc[ne]
double E_start[ne], I_start[ni]
objref vol
strdef source_path, target_path 
objref savdata, recv 
recv=new Vector()
recv.record(&soma.v(0))
vol= new Vector()
//==============================================================================

access soma
	distance()

//==============================functions=======================================
proc step() {	local i
	fadvance()
		if(ngraph!=0) {
			for i=0, ngraph-1{
				g[i].plot(t)
				g[i].flush()
				doNotify()
			}
		}
}

proc run() { local j
	init()
	if(ngraph!=0) {
		for j=0, ngraph-1{
				g[j].begin()
		}
	}	
	while(t<tstop) {		
	step()}	
}
//==============================================================================

//====================initialize voltage clamp==================================
objref clampobj
soma{
  clampobj = new SEClamp(.5)
  clampobj.dur1=1
  clampobj.amp1=0
  clampobj.rs=1e-2
}

objref irec
irec =new Vector()
irec.record(&clampobj.i)
//==============================================================================


proc main() { local i, j
	
	savdata = new File()
	savdata.wopen(target_path)
//=========================read in input locations and times====================	
	ropen(source_path)
  for j=0, ne-1{ 	E_loc[j] = fscan() }
  for i=0, ni-1{ 	I_loc[i] = fscan() }

  for j=0, ne-1{ 	E_start[j] = fscan()
  E_start[j]=E_start[j]+400 }
  for i=0, ni-1{ 	I_start[i] = fscan() 
  I_start[i]=I_start[i]+400}
	ropen()
   
//========================set synaptic inputs===================================
	for i=0, ni-1{ 		
		
	  dend[I_loc[i]] {
			 				
		I_dist=distance(0.5)
		print "I_dist	", I_dist
		
    Istim[i] = new ExpSynn(0.5)
    Istim[i].onset = 0    //(ms)
    Istim[i].tau1 = 5//6     //(ms)
    Istim[i].tau2 = 7.8//18    //(ms)
    Istim[i].gmax =1e-3    //(uS)
    Istim[i].e = -80      //(mV) 
	  }	
	}
	
	for j=0, ne-1{ 		
		
	  dend[E_loc[j]] { 
	  
		E_dist=distance(0.5)
		print "E_dist	", E_dist 
	  
    Estim[j] = new ExpSynn(0.5)  	
    Estim[j].onset = 0  //(ms)
    Estim[j].tau1 = 6//5   //(ms)
    Estim[j].tau2 = 18//7.8   //(ms)
    Estim[j].gmax = 5e-5  //(uS)
    Estim[j].e = 0       //(mV)
		
 	  }
	}

//==============================================================================
	
//=======E record without Vclamp to measure the pure E conductance==============

clampobj.dur1=1
	      
  for i=0, ni-1{	      
		Istim[i].onset=I_start[i]+10000
	}
			
  for j=0, ne-1{
		Estim[j].onset=E_start[j]
  }
 
run()	
vol = recv.c.sub(0)	
vol.printf(savdata,"%g \t")
irec.printf(savdata,"%g \t")

//========I record without Vclamp to measure the pure I conductance ============

clampobj.dur1=1

  for i=0, ni-1{	      
		Istim[i].onset=I_start[i]
	}
			
  for j=0, ne-1{
		Estim[j].onset=E_start[j]+10000
  }
 
run()	
vol = recv.c.sub(0)	
vol.printf(savdata,"%g \t")
irec.printf(savdata,"%g \t")

//===========E and I are given together, and Vclamp is used=====================

clampobj.dur1=tstop

for k = 1,5{
	//clampobj.amp1=(k-2)*20-70    //somatic voltage is clamped at different level 
  clampobj.amp1=-110+k*10    //somatic voltage is clamped at different level
	  for i=0, ni-1{	      
		Istim[i].onset=I_start[i]
	}
			
  for j=0, ne-1{
		Estim[j].onset=E_start[j]
  }

	run()	
	vol = recv.c.sub(0)	
	vol.printf(savdata,"%g \t")
	irec.printf(savdata,"%g \t")

	}
	 		                                       
	savdata.close()                                             
	print "Done!\n"                     

}	
//==============================================================================  

proc Normal(){
		
		sprint(source_path, "%s", "input_location_time.dat")
		sprint(target_path, "%s", "multi_EI_Vclamp_REV80.dat")
		main()
		
}

Normal()

	

